<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"/usr/share/xml/docbook/schema/dtd/4.2/docbookx.dtd" [
<!ENTITY auml "&#228;">
<!ENTITY mdash "&#8212;">
<!ENTITY nbsp "&#160;">
<!ENTITY kdsoap "KD&#160;SOAP">
<!ENTITY kdsoap1 "KD&#160;SOAP&#160;1">
<!ENTITY kdsoap1_0 "KD&#160;SOAP&#160;1.0">
<!ENTITY kdsoap1_1 "KD&#160;SOAP&#160;1.1">
<!ENTITY kdsoap_cur_version "1.1">
<!ENTITY kdwsdl2cpp "kdwsdl2cpp code generator">
]>
<book>
  <bookinfo>
    <title>&kdsoap; Programmer's Manual</title>

    <corpauthor>The &kdsoap; Team</corpauthor>

    <corpname>Klar&auml;lvdalens Datakonsult AB</corpname>

    <releaseinfo>Version &kdsoap_cur_version;</releaseinfo>

    <legalnotice>
      <para>The contents of this manual and the associated &kdsoap; software
      are the property of Klar&auml;lvdalens Datakonsult AB and are copyrighted.
      &kdsoap; is available under two different licenses, depending on the
      intended use of this product:</para>

      <itemizedlist>
        <listitem>
          <para>Commercial users (i.e. people intending to develop a
          commercial product using &kdsoap;) need to order a commercial
          license from Klar&auml;lvdalens Datakonsult AB.</para>
        </listitem>

        <listitem>
          <para>The &kdsoap; library for web service clients is also available
          for creating non-commercial, open-source software under the GNU General Public License,
          version 2 or 3. The library for providing web services is also available under the
          GNU Affero General Public Licence, version 3.
          See LICENSE.GPL.txt and LICENCE.AGPL3.txt for the full licence texts.</para>
        </listitem>
      </itemizedlist>

      <para>It is your responsibility to decide which license type is
      appropriate for your intended use of &kdsoap;. Any reproduction of this
      manual and the associated &kdsoap; software in whole or in part that is
      not allowed by the applicable license is strictly prohibited without
      prior written permission by Klar&auml;lvdalens Datakonsult AB.</para>

      <para>&kdsoap; and the &kdsoap; logo are trademarks or registered
      trademarks of Klar&auml;lvdalens Datakonsult AB in the European Union, the
      United States, and/or other countries. Other product and company names
      and logos may be trademarks or registered trademarks of their respective
      companies.</para>
    </legalnotice>

    <copyright>
      <year>2009-2011</year>

      <holder>Klar&auml;lvdalens Datakonsult AB</holder>
    </copyright>
  </bookinfo>

  <!-- =====================Introduction============================== -->

  <chapter id="chapter_introduction">
    <title id="chtxt_introduction">Introduction</title>

    <titleabbrev id="chnum_introduction">Chapter 1</titleabbrev>

    <para>Welcome to the &kdsoap; Programmer's Manual. &kdsoap; is
    Klar&auml;lvdalens Datakonsult AB's web service access package for Qt applications. This
    manual will get you started creating your own web service clients or web service providers.
    It covers the fundamentals of coding with &kdsoap; and provides plenty of tips for
    advanced programmers.</para>

    <itemizedlist>
      <listitem>
        <para>Depending on your version of &kdsoap;, you will find a unique
        <filename>INSTALL.txt</filename> file containing instructions on how to
        install &kdsoap; on your platform. Each instruction set also includes
        step-by-step description of how to build &kdsoap; directly from the
        source code.</para>
      </listitem>

      <listitem>
        <para>&kdsoap; also comes with an extensive "API Reference" Manual
        (generated from the source code itself). It is available both as a PDF
        file and as browsable HTML pages.</para>
      </listitem>
    </itemizedlist>

    <para>The "API Reference" is an excellent resource for topics not covered
    in the Programmer's Manual. Both the Programmer's Manual and API Reference
    are designed to be used in conjunction with each other. If you have a
    question not covered in the following chapters, check the API reference
    for a solution (or in <xref linkend="txt_appendix_qanda" /> at the end of
    this manual).</para>

    <itemizedlist>
      <listitem>
        <para>What is &kdsoap;?</para>

        <para>&kdsoap; is a tool for creating client applications for web services which export their service API as SOAP objects. As of &kdsoap1_1; it can also be used to implement such services. A web service is a program that provides a machine-accessible interface to its functionality via HTTP. One way of handling this kind of remote method calls is the SOAP standard, which describes method calls, their parameters and return values as XML documents.</para>

        <para>The library provides an abstraction layer for both the actual transport as well as the construction of data objects and method calls. The latter relieves application developers from manually writing XML marshalling and demarshalling code, allowing them to build arbitrary complex data structures using simple C++ classes. The transport abstraction for the client use case provides both synchronous as well as Qt signal/slot based asynchronous remote method call and response handling. The server use case supports both single threaded as well as multi threaded operations.</para>

        <para>The &kdwsdl2cpp; delivered alongside the library provides additional means for increasing developer productivity by either generating proxy API for a target web service (client use case) or a server stub (server use case) based on a formal WSDL service description. Using classes generated by this approach adds build time type checking and in-process like object behavior, i.e. using C++ data types as parameters and return values of each of the web service's methods.</para>
      </listitem>

      <listitem>
        <para>What can you use &kdsoap; for?</para>

        <para>&kdsoap; is used by a variety of programs for a variety of
        different purposes. For example, one application uses &kdsoap; to
        access data from a CRM system such as SugarCRM or Salesforce.
        For other examples, visit our web site at <ulink
        url="http://www.kdab.com/kd-soap/"><filename>http://www.kdab.com/kd-soap/</filename></ulink></para>
      </listitem>
    </itemizedlist>

    <sect1>
      <title id="prerequisites">What You Should Know</title>

      <para>You should be familiar with writing Qt applications, and have a
      working knowledge of C++. When you are in doubt about how a Qt class
      mentioned in this Programmer's Manual works, please check the Qt
      reference documentation or a good book about Qt. Also to browse
      &kdsoap; API Reference start with the file
      <filename>doc/html/index.html</filename> or <ulink url="http://docs.kdab.com/kdsoap/"><filename>http://docs.kdab.com/kdsoap/</filename></ulink>.</para>
    </sect1>

    <sect1>
      <title id="structure">The Structure of This Manual</title>

      <para>Where do we start?</para>

      <para>The first part of this manual begins with an introduction to the &kdsoap1; client API,
      then goes through the basic steps and methods for the user to create her own
      SOAP client. Each subsequent chapter covers more advanced material like different
      variations of asynchronous calls or providing additional data to the transport protocol
      layer.</para>
      
      <para>The second part starting at <xref linkend="chtxt_server_api" /> demonstrates in a
      similar fashion how the server API introduced in &kdsoap1_1; can be used to implement
      a SOAP web service.</para>
      
      <para><xref linkend="chtxt_kdwsdl2cpp" /> finally describes a less generic but easier and safer to use approach using generated code.</para>

      <para>We provide you with many more example programs than shown in this
      manual. We recommend that you try them out and run them. Have a
      look at the code and experiment with the various settings, both by
      adjusting them via the user interface, and by trying out your own code
      modifications.</para>
    </sect1>

    <sect1>
      <title>What's next</title>

      <para>In the next chapter we introduce the &kdsoap1; API.</para>
    </sect1>
  </chapter>

  <!-- ============ Kd Soap 1.0 Client Api Introduction ============= -->

  <chapter id="chapter_client_api">
    <title id="chtxt_client_api">&kdsoap1; Client API Introduction</title>

    <titleabbrev id="chnum_client_api">Chapter 2</titleabbrev>

    <para>&kdsoap; builds on technologies introduced with Qt 4, most importantly <classname>QNetworkAccessManager</classname>.
    This ensures that HTTP requests done by &kdsoap; will support</para>
    <itemizedlist>
      <listitem>
        <para>following the operating system's proxy settings,</para>
      </listitem>
      <listitem>
        <para>processing of cookies,</para>
      </listitem>
      <listitem>
        <para>and doing HTTP authentication using the following methods: Basic, NTML version 1 (version 2 is not supported by Qt yet) and Digest-MD5. </para>
      </listitem>
    </itemizedlist>
    <sect1>
      <title id="apioverview">Overview</title>

      <sect2>
        <title id="apisample" xreflabel="code sample">Code Sample</title>

        <programlisting>
const QString endPoint =
  QLatin1String("http://www.27seconds.com/Holidays/US/Dates/USHolidayDates.asmx");
const QString messageNamespace =
  QLatin1String("http://www.27seconds.com/Holidays/US/Dates/");

KDSoapClientInterface client(endPoint, messageNamespace);

KDSoapMessage message;
message.addArgument(QLatin1String("year"), 2010);

KDSoapMessage response = client.call(QLatin1String("GetValentinesDay"), message);
        </programlisting>

        <para>The code example shows the three basic steps for calling a web service method.</para>

        <itemizedlist>
          <listitem>
            <para>Setup of the proxy object used for interfacing with the web service.</para>
          </listitem>
          <listitem>
            <para>Construction of the method call's parameters.</para>
          </listitem>
          <listitem>
            <para>Performing the remote call.</para>
          </listitem>
        </itemizedlist>

        <para>The response, i.e. either the call's return value or an error structure, is delivered in the same abstract form the call parameters where constructed in. Therefore simple use cases like this sample only require use of two classes: <classname>KDSoapClientInterface</classname> and <classname>KDSoapMessage</classname></para>
      </sect2>

      <sect2>
        <title id="apiconcepts">Concepts</title>

        <para>For now, to get an overview about the &kdsoap1; API and its
        features, you need to understand the following basic concepts:</para>

        <itemizedlist>
          <listitem>
            <para>All interactions with web services happens through instances of <classname>KDSoapClientInterface</classname>. One such instance is needed for each web service an application wants to interact with, i.e. it is not possible to switch an instance to a different service at runtime.</para>
            <para><classname>KDSoapClientInterface</classname> provides functionality to make synchronous and asynchronous method calls. The first can be convenient in non-interactive applications or when used in threads, the latter is also suitable for use in a GUI application's main thread.</para>
          </listitem>

          <listitem>
            <para>Web service method calls require the name of the method and a single parameter object of type <classname>KDSoapMessage</classname>. Optional data such as SOAP request headers, e.g. for passing a session identifier alongside the request, can be passed with each method call or set permanently on the client interface instance.</para>
            <para>The single parameter object can contain an arbitrary number of named parameter values, each potentially again being a list. Simple types such as numbers or strings are representable by a single parameter value; complex types, e.g. a structure with multiple members, can be represented as a list of said members.</para>
            <programlisting>
KDSoapMessage message;

// add a simple type argument
message.addArgument(QLatin1String("text"), "some text");

// add a structured type argument
QRect rect(0, 0, 100, 200);
KDSoapValueList rectArgument;
rectArgument.addArgument(QLatin1String("x"), rect.x());
rectArgument.addArgument(QLatin1String("y"), rect.y());
rectArgument.addArgument(QLatin1String("width"), rect.width());
rectArgument.addArgument(QLatin1String("height"), rect.height());

message.addArgument(QLatin1String("rect"), rectArgument);
            </programlisting>

            <note>
                <para>When manually constructing message call arguments, it is the responsibility of the developer to provide &kdsoap; with marshalling hints if necessary. These hints are either defined as enums of the respective &kdsoap; class or through explicit type specification</para>
              <itemizedlist>
                <listitem>
                    <para><constant>KDSoapClientInterface::SoapVersion</constant></para>
                </listitem>
                <listitem>
                    <para><constant>KDSoapMessage::Use</constant></para>
                </listitem>
                <listitem>
                    <para><methodname>KDSoapValue::setType()</methodname></para>
                </listitem>
                <listitem>
                    <para><methodname>KDSoapValueList::setArrayType()</methodname></para>
                </listitem>
              </itemizedlist>
              <para>See <xref linkend="chtxt_kdwsdl2cpp" /> for an approach on how to automate that.</para>
            </note>
          </listitem>

          <listitem>
            <para>The call result is also of type <classname>KDSoapMessage</classname>, allowing structured data to be returned, similar to how a C++ method can return a class type.</para>
            <para>SOAP calls can result in an error being returned rather than a method return value, e.g. the web service might not be reachable due to network problems, the method might be unknown to the web service, etc. In such cases the returned <classname>KDSoapMessage</classname> is marked as a fault message, see <methodname>KDSoapMessage::isFault()</methodname>.</para>
          </listitem>
        </itemizedlist>
      </sect2>
    </sect1>
  </chapter>

  <chapter id="chapter_calls">
    <title id="chtxt_calls">Synchronous vs. Asynchronous Calls</title>

    <titleabbrev id="chnum_calls">Chapter 3</titleabbrev>

      <para>As shown in the <xref linkend="apisample" />, calling a web service method is mapped by &kdsoap; to calling a method on a <classname>KDSoapClientInterface</classname> instance. This kind of abstraction makes day-to-day work with web services convenient, however, it is important to consider the involved processing steps when deciding where and how the application makes use of this simplification layer.</para>
      <para>The involved steps in the client to web service direction are:</para>

      <itemizedlist>
        <listitem>
          <para>Creation of an XML document for describing the method to call and its parameters.</para>
        </listitem>
        <listitem>
          <para>Sending of the XML document via a network connection using HTTP.</para>
        </listitem>
        <listitem>
          <para>Processing of the XML document on the web service's host.</para>
        </listitem>
      </itemizedlist>

      <para>The same applies for the reverse direction with the only difference being the semantics of the document content (method return value or error instead of method call).</para>
      <para>While the first and last step require some time for XML processing they are, depending on complexity of the involved parameter or return value data types, negligible compared to the middle one, due to it being subject to network latency and bandwidth limitations which in turn are often unpredictable.</para>

    <sect1>
      <title id="synchronouscalls">Synchronous Calls</title>

      <para>Calls performed by invoking the <classname>KDSoapClientInterface</classname>'s <methodname>call()</methodname> method are synchronous calls. Synchronous means that the calling thread will not return from the method before it has completed the full roundtrip processing. Due to its similarity with an in-process method call it is the easier to use this variant supported by &kdsoap;. However, it should only be used when its blocking nature is of little concern, e.g. in a worker thread or in a non-interactive application like a command line tool.</para>
    </sect1>

    <sect1>
      <title id="asynchronouscalls">Asynchronous Calls</title>

      <para>Calls performed by invoking the <methodname>KDSoapClientInterface::asyncCall()</methodname> method are asynchronous calls. Asynchronous means that the calling thread will only process step one (XML generation) and create an HTTP transfer request. It will neither wait for the transfer's execution nor any response, but instead will return an instance of <classname>KDSoapPendingCall</classname>. This object then serves as a handle to determine at any later point whether the whole processing chain has been completed and what the resulting return value is.</para>

     <para>Performing the call from <xref linkend="apisample" /> in an asynchronous way:</para>
     <programlisting>
...
// mPendingCall is a member variable so it lives beyond
// the scope of the method creating it and so is mClient
mPendingCall = mClient-&gt;asyncCall(QLatin1String("GetValentinesDay"), message);

...

if (mPendingCall.isFinished()) {
  KDSoapMessage response = mPendingCall.returnMessage();
}
     </programlisting>

     <para>Of course, checking for completion at some arbitrary time might not very be useful, instead the application will most likely want to be notified about the call's completion. This is supported by <classname>KDSoapPendingCallWatcher</classname>.</para>
     <programlisting>
...

KDSoapPendingCall pendingCall =
  mClient-&gt;asyncCall(QLatin1String("GetValentinesDay"), message);

// create a watcher object that will signal the call's completion
KDSoapPendingCallWatcher* watcher =
  new KDSoapPendingCallWatcher(pendingCall, this);
connect(watcher, SIGNAL(finished(KDSoapPendingCallWatcher*)),
        this, SLOT(pendingCallFinished(KDSoapPendingCallWatcher*)));
...

void MyClass::pendingCallFinished(KDSoapPendingCallWatcher* pendingCall)
{
  KDSoapMessage response = pendingCall->returnMessage();
}
     </programlisting>

     <para>Both variants support having more than one call pending, i.e. calling another web service method while a previous call is still being processed. However, there might be restrictions on the web service's side, e.g. not allowing more than one call per client at any given time to limit resource usage. In general it is also undetermined whether the results arrive in the same or a different order than the one the requests were sent in. A safer solution for multiple concurrent calls is to use multiple instances of KDSoapClientInterface, which results in multiple independent connections to the web service.</para>

     <para>Sometimes it might not be necessary at all to know whether a call succeeded or what its result was. In such cases use <methodname>KDSoapClientInterface::callNoReply()</methodname> instead.</para>
    </sect1>
  </chapter>

  <chapter id="chapter_headers">
    <title id="chtxt_headers">SOAP Headers</title>

    <titleabbrev id="chnum_headers">Chapter 4</titleabbrev>

    <para>SOAP specifies a mechanism to transmit data alongside the actual SOAP document, so called SOAP headers. The term headers indicates that these values will be part of the HTTP headers section which makes them accessible for components involved in the transfer which do understand HTTP but might not have SOAP capabilities, e.g. the web server or a load balancer in front of it.</para>

    <para>&kdsoap; supports headers on a per method call basis as well as keeping them as local state across calls.</para>

    <sect1>
      <title id="perinterfaceheaders">SOAP Headers per Client Interface</title>

      <para>One of the most common use cases for SOAP headers is providing session information for the recipient of the SOAP transmission. This is mainly necessary because HTTP is a stateless interfacing scheme, where each call arrives through a new network connection. In order to associate such independent connections to the same client, the first connection establishes some sort of session tracking, usually in the form of a session identifier string. This identifier then has to be provided with each call.</para>

      <para>While a header containing such an identifier could be provided at each method call, it will usually be more convenient to let &kdsoap; take care of that by setting the header as a kind of local state on the <classname>KDSoapClientInterface</classname> instance:</para>

     <programlisting>
KDSoapMessage message;
message.addArgument(QLatin1String("user"), userName);
message.addArgument(QLatin1String("password"), password);

KDSoapMessage response = client.call(QLatin1String("Login"), message);
const QString sessionId = response.arguments()[0].value().toString();

KDSoapMessage header;
header.addArgument(QLatin1String("SessionId"), sessionId);

client.setHeader(QLatin1String("SessionHeader"), header);

...

response = client.call(QLatin1String("GetUserDetails"), KDSoapMessage());
     </programlisting>

     <para>The example above assumes a fictitious web service which requires a login call to establish a user's authentification and then requires the returned session token to be used for any subsequent call. Setting the identifier as a header allows &kdsoap; to take care of sending it alongside any call invoked through the same <classname>KDSoapClientInterface</classname> instance.</para>

     <para>Please note that the actual name of the header argument, in the case of this example <literal>"SessionId"</literal>, is part of the web service's interface description, while the name passed to <methodname>KDSoapClientInterface::setHeader()</methodname> is purely used for identifying the header between &kdsoap; and the application and can thus be chosen by the user herself.</para>
    </sect1>

    <sect1>
      <title id="percallheaders">SOAP Headers for Single Calls</title>

      <para>Sometimes it might not be possible to use a header across calls, e.g. the value of the header changing with each call or be specific to the method being called. In cases like this it is necessary to provide the headers when invoking the <methodname>KDSoapClientInterface::call()</methodname> (or one of its asynchronous variants):</para>

     <programlisting>
KDSoapMessage header;
header.addArgument(QLatin1String("SessionId"), sessionId);

KDSoapHeaders headers;
headers &lt;&lt; header;

response = client.call(QLatin1String("GetUserDetails"),
                       KDSoapMessage(), QString(), headers);
     </programlisting>

     <sect2>
       <title id="soapaction">SOAP Action</title>

       <para>As already hinted in the example above, there is another per-call parameter: SOAP Actions. It is a mandatory SOAP header but allowed to be empty. Its purpose as suggested by the SOAP specification is to express the intent of the call. In most cases this can be left empty and let &kdsoap; generate a valid value based on the method name.</para>

       <para>As an example of where it is necessary to actually set this, see Google's search API:</para>

       <programlisting>
KDSoapMessage message;

...

const soapAction = QLatin1String("urn:GoogleSearchAction");
KDSoapMessage response =
  client.call(QLatin1String("doGoogleSearch"), message, soapAction);
       </programlisting>
     </sect2>
    </sect1>
  </chapter>

  <!-- ============ Kd Soap 1.1 Server Api Introduction ============= -->

  <chapter id="chapter_server_api">
    <title id="chtxt_server_api">&kdsoap1_1; Server API Introduction</title>

    <titleabbrev id="chnum_server_api">Chapter 5</titleabbrev>
    
    <para>Implementations of SOAP web services require two problems to be solved: low-level HTTP connection handling and high-level SOAP call handling. &kdsoap;'s solution follows a layered approach, with the low-level part being fully implemented already and the high-level part being delegated to a user-provided implementation of an interface.</para>
    
    <sect1>
      <title>Connection Handling</title>
      
      <para>The &kdsoap; server component contains all necessary facilities to handle SOAP calls, including classes for receiving and processing HTTP connections via TCP/IP. In other words a program deploying &kdsoap; to provide its SOAP service does not require any additional web server of any sort, i.e. stand-alone SOAP web service capability.</para>
      
      <para>Listening for and accepting of TCP/IP connections is handled by <classname>KDSoapServer</classname>. Its socket level connection handling supports normal, unencrypted connections as well as SSL encrypted ones. Encryption capability is one of the class' features that can be turned on and off through respective flags:</para>
      
      <programlisting>
// assuming mSoapServer is a member of type KDSoapServer

// enable SSL encryption support
KDSoapServer::Features features = mSoapServer.features();
features |= KDSoapServer::Ssl;
mSoapServer.setFeatures( features );
      </programlisting>
      
      <para>Since <classname>KDSoapServer</classname> is derived from <classname>QTcpServer</classname>, it can be treated as such when it comes to listening for TCP/IP connection, e.g. which interface(s) and port to listen on, whether to wait blockingly for connections or using the current thread's event loop for non-blocking operations.</para>
      
      <para>On top of that <classname>KDSoapServer</classname> supports two strategies for handling the individual client connections:</para>
      <itemizedlist>
        <listitem>
          <para>Single-Threaded: processing all client connections and respectively their SOAP calls within the same thread that is doing the connection listening.</para>
        </listitem>

        <listitem>
          <para>Multi-Threaded: processing client connections and respectively their SOAP calls within different worker threads, managed by a thread pool provided by <classname>KDThreadPool</classname>.</para>
        </listitem>
      </itemizedlist>
      
      <para>By default <classname>KDSoapServer</classname> will operate in single-threaded manner, enabling multi-threading is however very simple:</para>
      
      <programlisting>
// assuming mSoapServer is a member of type KDSoapServer

mSoapServer.setThreadPool( new KDThreadPool( this ) );
      </programlisting>
      
      <para>A thread pool instance can even be shared between server instances:</para>
      <programlisting>
// assuming mSoapServer1 and mSoapServer2 are members of type KDSoapServer

KDThreadPool *threadPool = new KDThreadPool( this );

mSoapServer1.setThreadPool( threadPool );
mSoapServer2.setThreadPool( threadPool );
      </programlisting>
    </sect1>
    
    <sect1>
      <title>SOAP Call Handling</title>

      <para>After <classname>KDSoapServer</classname> has determined that an incoming connection is indeed a SOAP call it is responsible for, it needs to delegate the actual SOAP method call to code provided by the web service's developer. It does that by calling a factory method and checking if the created object has indeed the interface it expects to have so it can the call that interface's methods to hand over the call's data to the application specific implementation.</para>
      
      <para>These delegates need to be of type <classname>QObject</classname> and implement the <classname>KDSoapObjectInterface</classname> interface. Taking the example if the holiday service used through-out this manual it could look like this:</para>
      
      <programlisting>
class HolidayService : public QObject, public KDSoapServerObjectInterface
{
    Q_OBJECT
    Q_INTERFACE(KDSoapServerObjectInterface)
    
public:
    void processRequest( const KDSoapMessage &amp;request,
                         KDSoapMessage &amp;response,
                         const QByteArray &amp;soapAction );
};
      </programlisting>
      
      <para>As mentioned earlier, <classname>KDSoapServer</classname> needs to be able to create instances of this class through a call to its factory method <methodname>createServerObject()</methodname>:</para>
      
      <programlisting>
class HolidayServer : public KDSoapServer
{
    Q_OBJECT
    
public:
    QObject* createServerObject()
    {
        return new HolidayService();
    }
};
      </programlisting>
      
      <note><para>When operating <classname>KDSoapServer</classname> in a multi-threaded fashion this method will be called by multiple threads.</para></note>
      
      <para>The <methodname>processRequest()</methodname> method of the actual call handler class is called for each successfully decodable SOAP request. The call's data is passed in through the <parameter>request</parameter> parameter with additional information being available through the <parameter>soapAction</parameter> parameter and through <methodname>KDSoapObjectInterface::requestHeaders()</methodname>.</para>
      
      <para>The implementor is expected to fill the <parameter>response</parameter> object with the call's result value(s). Additional response headers can be set through <methodname>KDSoapObjectInterface::setResponseHeaders()</methodname>.</para>
      
      <note><para>In the event of an error that needs to be reported back to the caller, e.g. wrong number, types or values of call arguments, use <methodname>KDSoapObjectInterface::setFault()</methodname> instead.</para></note>
      
      <para>Example implementation for the HolidayService's <methodname>GetValentinesDay</methodname> method:</para>
      
      <programlisting>
void HolidayService::processRequest( const KDSoapMessage &amp;request,
                                     KDSoapMessage &amp;response,
                                     const QByteArray &amp;soapAction )
{
    const QString method = request.name();
    if ( method == QLatin1String( "GetValentinesDay" ||
         soapAction == "http://www.27seconds.com/Holidays/US/Dates/GetValentinesDay" )
    {
        // we expect the year parameter in "request"
        const KDSoapValueList args = request.childValues();
        
        // add check for args.count() == 1 otherwise fault
        
        const KDSoapValue value = args.at( 0 );
        
        // add check if value.name() == "year" otherwise fault
        
        const int year = value.value().value&lt;int&gt;();
        
        // create Valentine's day date for given year
        const QDate date( year, 2, 14 );
        const QDateTime dateTime( date );
        const KDDateTime result( dateTime );
        
        // create response content
        KDSoapValue resultValue( QLatin1String( "GetValentinesDayResponse" ),
                                 QVariant()
                               );
        KDSoapValueList &amp; resultArgs = resultValue.childValues();
        resultArgs.append( KDSoapValue( QLatin1String( "GetValentinesDayResult" ),
                                        result.toDateString(),
                                        KDSoapNamespaceManager::xmlSchema2001(),
                                        QLatin1String("dateTime")
                                      )
                         );
                          
        // fill return object                  
        response = resultValue;                  
    }
    else // unhandled method, let base class deal with that
        KDSoapServerObjectInterface::processRequest( request, response, soapAction );
}
      </programlisting>
      
    </sect1>
  </chapter>

  <chapter id="chapter_kdwsdl2cpp">
    <title id="chtxt_kdwsdl2cpp">Using WSDL to Generate Client or Server API</title>

    <titleabbrev id="chnum_kdwsdl2cpp">Chapter 6</titleabbrev>

    <sect1>
      <title id="wsdlintroduction">Introduction</title>

      <para>Most SOAP based web services are formally described in an XML based markup language called web service description language (WSDL). Such WSDL documents describe web service methods, their parameters and return values, as well as possible errors in a formalized way that makes them viable as input for code generation tools.</para>

      <para>Compared to the generic approach described in the earlier chapters of this manual, using a generated client or server API introduces several additional advantages:</para>

      <itemizedlist>
        <listitem>
          <para>Named methods: instead of referring to web service methods by names as string parameters to a generic <methodname>call()</methodname> method, a client interface generated from a WSDL document will have C++ methods for each of the web service's methods. Instead of handling all method calls in a generic <methodname>processRequest()</methodname> method, a generated server stub will have pure virtual C++ methods for each of the web service's methods which can then just be implemented by overriding them in a class derived from the generated stub.</para>
        </listitem>

        <listitem>
          <para>Type-specific classes: instead of building a single message object containing the method's parameters as lists of named values, methods of a generated client or server interface take C++ types for each of their parameters. If such a parameter is a type described in the WSDL document, a matching class with suitably named methods and again specific types will have been generated as well.</para>
        </listitem>

        <listitem>
          <para>Build time checks: as a result of neither methods nor parameter or return types being generic anymore, typos in method or parameter names, missing parameters and some forms of invalid parameter contents can now be caught by the C++ compiler instead of resulting in a SOAP error at runtime during method invocation.</para>
        </listitem>
      </itemizedlist>

      <para>&kdsoap; has full support for this powerful approach through its &kdwsdl2cpp; code generation tool. The following sections document how to use it and the client or server API it generates.</para>
    </sect1>

    <sect1>
      <title id="usingkdwsld2cpp">Using &kdwsdl2cpp;</title>

      <para>Before using &kdwsdl2cpp;, it is necessary to obtain the WSDL document describing the target web service and have it available as a local file. It is usually available as a download on a website associated with the web service or similar online distribution methods.</para>

      <para>Code generation using &kdwsdl2cpp; requires two steps: one to generate the header file and one to generate the source file. For example, when processing the <filename>holidays.wsdl</filename> file (which can be found in <filename>examples/holidays_wsdl</filename>) the following two commands need to be executed for the client-side use case:</para>

      <para><userinput>kdwsdl2cpp -o wsdl_holidays.h holidays.wsdl</userinput></para>

      <para>This creates a header file <filename>wsdl_holidays.h</filename> (choice of file name is up to the user), which will then contain the declarations of all data classes described in th WSDL file as well as the class representing the web service's interface.</para>

      <para><userinput>kdwsdl2cpp -o wsdl_holidays.cpp -impl wsdl_holidays.h holidays.wsdl</userinput></para>

      <para>This creates a source file <filename>wsdl_holidays.cpp</filename> (choice of file name is again up to the user) using the header file <filename>wsdl_holidays.h</filename> as the include for class declarations.</para>
      
      <para>The server-side use case is almost equivalent, the only difference is that an additional <parameter>-server</parameter> option has to be passed to &kdwsdl2cpp; at both invocations:</para>
      
      <para><userinput>kdwsdl2cpp -server -o wsdl_holidays.h holidays.wsdl</userinput></para>
      <para><userinput>kdwsdl2cpp -server -o wsdl_holidays.cpp -impl wsdl_holidays.h holidays.wsdl</userinput></para>
    </sect1>

    <sect1>
      <title id="generatedclientcode">Using the Generated Client Code</title>

      <para>The generated client-side code for the example call used through out this manual looks like this:</para>
      <programlisting>
class USHolidayDates : public QObject
{
    Q_OBJECT

public:
    USHolidayDates( QObject* parent = 0 );
    ~USHolidayDates();

    TNS__GetValentinesDayResponse
      getValentinesDay( const TNS__GetValentinesDay&amp; parameters );

    void asyncGetValentinesDay( const TNS__GetValentinesDay&amp; parameters );

    void getValentinesDayDone( const TNS__GetValentinesDayResponse&amp; parameters );

    void getValentinesDayError( const KDSoapMessage&amp; fault );
};
      </programlisting>
      <para>This is an excerpt of the generated web service interface class. It is a subclass of <classname>QObject</classname> so it can make use of signals for delivering asynchronous results. Both synchronous as well as asynchronous calls take an instance of the generate class <classname>TNS__GetValentinesDay</classname> as their only parameter. The synchronous variant returns an instance of class <classname>TNS__GetValentinesDayResponse</classname> once it has completed the call, while the asynchronous <methodname>asyncGetValentinesDay()</methodname> returns without value. Its results are delivered through one of the two signals: <methodname>getValentinesDayDone()</methodname> which carries an instance of the same response class returned by the synchronous <methodname>getValentinesDay()</methodname>, or <methodname>getValentinesDayError()</methodname> which carries a fault message (see <xref linkend="apiconcepts" />).</para>

      <programlisting>
class TNS__GetValentinesDay
{
public:
    void setYear( int year );
    int year() const;
};
      </programlisting>

      <para>This is an excerpt of the generated request parameter class, using the native integer type for the year parameter.</para>

      <programlisting>
class TNS__GetValentinesDayResponse
{
public:
    void setGetValentinesDayResult( const QDateTime&amp; getValentinesDayResult );
    QDateTime getValentinesDayResult() const;
};
      </programlisting>

      <para>This is an excerpt of the generated return value class, using Qt's <classname>QDateTime</classname> to represent the resulting date.</para>

      <para>Deploying these classes to perform the example call:</para>

      <programlisting>
USHolidayDates client;

TNS__GetValentinesDay request;
resquest.setYear( 2010 );

TNS__GetValentinesDayResponse response = client.getValentinesDay( request );
const QDateTime valentinesDay = response.getValentinesDayResult();
      </programlisting>
    </sect1>

    <sect1>
      <title id="generatedservercode">Using the Generated Server Code</title>

      <para>The generated server-side code for the example call looks like this:</para>
      <programlisting>
class USHolidayDatesServerBase : public QObject, public KDSoapServerObjectInterface
{
    Q_OBJECT

    Q_INTERFACES(KDSoapServerObjectInterface)

public:
    virtual TNS__GetValentinesDayResponse
        getValentinesDay( const TNS__GetValentinesDay&amp; parameters ) = 0;    
};        
      </programlisting>
      <para>This is an excerpt of the generated web service stub class. It is a subclass of <classname>QObject</classname> so it can make use of Qt's mechanism for handling C++ interfaces. It is also a subclass of <classname>KDSoapServerObjectInterface</classname> which provides the interface between the connection handling code and the SOAP method processing code. The interface's <methodname>processRequest()</methodname> method has been provided by the code generator, thus leaving only the SOAP callable methods to implement:
      </para>
      
      <programlisting>
class USHolidayDatesServer : public USHolidayDatesServerBase
{
    Q_OBJECT
    
public:
    virtual TNS__GetValentinesDayResponse
        getValentinesDay( const TNS__GetValentinesDay&amp; parameters )
    {
        const int year = parameters.year();
        
        // Valentine's day is trivial since it is always February 14th of the year
        const QDate date( year, 2, 14 );
        const QDateTime dateTime( date );
        const KDDateTime resultValue( dateTime );
        
        // create and fill response object
        TNS__GetValentinesDayResponse response;
        response.setGetValentinesDayResult( resultValue );
        
        return response;
    }
};
      </programlisting>
      
      <para>Additional to deriving from the generated class and implementing all pure virtuals, we need an instance of the connection handling class based on <classname>KDSoapServer</classname> as described in the chapter on server implementation without code generation.
      Its <methodname>createServerObject()</methodname> method can simply return new instances of the class derived from the generated stub:</para>
      
      <programlisting>
class HolidaysServer : public KDSoapServer
{
    Q_OBJECT
    
public:
    virtual QObject* createServerObject()
    {
        return new USHolidayDatesServer;
    }
};
      </programlisting>      
    </sect1>
      
    <sect1>
      <title id="kdwsdl2cppqmake">Using &kdwsdl2cpp; with QMake</title>

      <para>While running &kdwsdl2cpp; manually and adding the resulting source and header file to a project's QMake <filename>.pro</filename> file works as expected, having QMake take care of the code generation makes it easier to adopt changes in the WSDL file.</para>

      <para>&kdsoap; supports this by making WSDL file processing similar to how QMake treats Qt Designer's <filename>.ui</filename> files. The necessary steps are:</para>

      <itemizedlist>
        <listitem>
          <para>Include the <filename>kdsoap.pri</filename> QMake include file in the project's <filename>.pro</filename> file. It is part of the &kdsoap; package and should be copied to the user's project directory.</para>
        </listitem>

        <listitem>
          <para>Add the WSDL files to the <literal>KDWSDL</literal> variable. For the example above it would look like this:</para>
          <programlisting>
KDWSDL = holidays.wsdl
          </programlisting>
          <para>By default this will generate client proxy classes, adding server stub classes can be achieved by specifying the necessary option like this:</para>  
          <programlisting>
KDWSDL_OPTIONS = -server          
          </programlisting>
          <para>Generated files will be prefixed with <literal>wsdl_</literal> and have the proper extension depending on file type. I.e. the above line will result in <filename>wsdl_holidays.h</filename> and <filename>wsdl_holidays.cpp</filename>.</para>
        </listitem>

        <listitem>
          <para>Set the environment variable <literal>KDSOAPDIR</literal> to the base path of your &kdsoap; build or install directory or provide it as a value to the <filename>qmake</filename> run.</para>
        </listitem>
      </itemizedlist>
    </sect1>
  </chapter>

  <appendix id="appendix_qanda">
    <title id="txt_appendix_qanda">Q&amp;A section</title>

    <titleabbrev>Appendix A</titleabbrev>

    <qandaset defaultlabel="qanda">
      <qandadiv>
        <title>Building and installing &kdsoap;</title>

        <qandaentry id="qa_install1">
          <question>
            <para>How can I build and install &kdsoap; from source?</para>
          </question>

          <answer>
            <para>Procedure to follow for building and installing &kdsoap; is
            described in file <filename>Install.src</filename>, please refer
            to that file for details.</para>
          </answer>
        </qandaentry>
      </qandadiv>

      <qandadiv>
        <title>Contacting &kdsoap; Support</title>

        <qandaentry id="qa_contact_support">
          <question>
            <para>How can I get help (or report issues, resp.) on
            &kdsoap;?</para>
          </question>

          <answer>
            <para>To report issues/problems, or ask for help on &kdsoap;,
            please send your mail with a description of your
            problem/question/wishes to the support address <ulink
        url="mailto:kdsoap-support@kdab.com">kdsoap-support@kdab.com</ulink>. Please include a description of your setup: CPU
            type, operating system with release number, compiler (version)
            used, any changes you made on libraries that are linked to...
            Just include every detail that might help us set up a comparable
            test environment in our labs.</para>

            <para>In most cases it will make sense to include a small sample
            program showing the problem you are describing. We will then
            reproduce the issue on our machines and either fix your sample
            code or adjust our own code (in case your reported issue might
            turn out to result from sub-optimal implementation in
            &kdsoap;).</para>

            <note>
              <para>Providing us with a compilable sample program file will
              help us find a good solution for the problem reported, as we
              will be using the same code that you have been trying to use
              yourself.</para>
            </note>

            <para>Often the easiest way to create such a sample program could
            be to look at one of our example programs, e.g.
            <filename>examples/holidays_wsdl/holidays.cpp</filename> and do something similar just with your WSDL file.</para>
            <para>If the web service is not available to us, e.g. if the software is not available as at least a trial version and you (or your customer) are not allowed to create a test account for us on your installation, we'll probably require logs of the SOAP communication as well.</para>
            <para>&kdsoap; has built-in functionality to print the SOAP communication to the application's standard output. To enable this, either set the environment variable <literal>KDSOAP_DEBUG</literal> to <literal>1</literal> or put the following code into the test application:</para>
            <programlisting>
qputenv( "KDSOAP_DEBUG", "1" );
            </programlisting>
          </answer>
        </qandaentry>
      </qandadiv>
    </qandaset>
  </appendix>
</book>
