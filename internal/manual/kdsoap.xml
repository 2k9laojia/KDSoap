<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"/usr/share/xml/docbook/schema/dtd/4.2/docbookx.dtd" [
<!ENTITY auml "&#228;">
<!ENTITY mdash "&#8212;">
<!ENTITY nbsp "&#160;">
<!ENTITY kdsoap "KD&#160;SOAP">
<!ENTITY kdsoap1 "KD&#160;SOAP&#160;1">
<!ENTITY kdsoap1_0 "KD&#160;SOAP&#160;1.0">
<!ENTITY kdsoap_cur_version "1.0">
<!ENTITY kdwsdl2cpp "kdwsdl2cpp code generator">
]>
<book>
  <bookinfo>
    <title>&kdsoap; Programmer's Manual</title>

    <corpauthor>The &kdsoap; Team</corpauthor>

    <corpname>Klarälvdalens Datakonsult AB</corpname>

    <releaseinfo>Version &kdsoap_cur_version;</releaseinfo>

    <legalnotice>
      <para>The contents of this manual and the associated &kdsoap; software
      are the property of Klarälvdalens Datakonsult AB and are copyrighted.
      &kdsoap; is available under two different licenses, depending on the
      intended use of this product:</para>

      <itemizedlist>
        <listitem>
          <para>Commercial users (i.e. people intending to develop a
          commercial product using &kdsoap;) need to order a commercial
          license from Klarälvdalens Datakonsult AB.</para>
        </listitem>

        <listitem>
          <para>&kdsoap; is also available for creating non-commercial,
          open-source software under the GNU General Public License, version
          ...</para>
        </listitem>
      </itemizedlist>

      <para>It is your responsibility to decide which license type is
      appropriate for your intended use of &kdsoap;. Any reproduction of this
      manual and the associated &kdsoap; software in whole or in part that is
      not allowed by the applicable license is strictly prohibited without
      prior written permission by Klarälvdalens Datakonsult AB.</para>

      <para>&kdsoap; and the &kdsoap; logo are trademarks or registered
      trademarks of Klarälvdalens Datakonsult AB in the European Union, the
      United States, and/or other countries. Other product and company names
      and logos may be trademarks or registered trademarks of their respective
      companies.</para>
    </legalnotice>

    <copyright>
      <year>2009-2010</year>

      <holder>Klarälvdalens Datakonsult AB</holder>
    </copyright>
  </bookinfo>

  <!-- =====================Introduction============================== -->

  <chapter id="chapter_introduction">
    <title id="chtxt_introduction">Introduction</title>

    <titleabbrev id="chnum_introduction">Chapter 1</titleabbrev>

    <para>Welcome to the &kdsoap; Programmer's Manual. &kdsoap; is
    Klarälvdalens Datakonsult AB's web service access package for Qt applications. This
    manual will get you started creating your own web service clients. It covers the
    fundamentals of coding with &kdsoap; and provides plenty of tips for
    advanced programmers.</para>

    <itemizedlist>
      <listitem>
        <para>Depending on your version of &kdsoap;, you will find a unique
        <filename>INSTALL</filename> file containing instructions on how to
        install &kdsoap; on your platform. Each instruction set also includes
        step-by-step description of how to build &kdsoap; directly from the
        source code.</para>
      </listitem>

      <listitem>
        <para>&kdsoap; also comes with an extensive "API Reference" Manual
        (generated from the source code itself). It is available both as a PDF
        file and as browsable HTML pages.</para>
      </listitem>
    </itemizedlist>

    <para>The "API Reference" is an excellent resource for topics not covered
    in the Programmer's Manual. Both the Programmer's Manual and API Reference
    are designed to be used in conjunction with each other. If you have a
    question not covered in the following chapters, check the API reference
    for a solution (or in <xref linkend="txt_appendix_qanda" /> at the end of
    this manual).</para>

    <itemizedlist>
      <listitem>
        <para>What is &kdsoap;?</para>

        <para>&kdsoap; is a tool for creating client applications for web services which export their service API as SOAP objects. A web service is a program that provides a machine accessible interface to its functionality via HTTP. One way of handling this kind of remote method calls is the SOAP standard, which describes method calls, their parameters and return values as XML documents.</para>

        <para>The library provides an abstraction layer for both the actual transport as well as the construction of data objects and method calls. The latter relieves application developers from manually writing XML marshalling and demarshalling code, allowing them to build arbitrary complex data structures using simple C++ classes. The transport abstraction provides both synchronous as well as Qt signal/slot based asynchronous remote method call and response handling.</para>

        <para>The &kdwsdl2cpp; delivered along side the library provides additional means for increasing developer productivity by generating proxy API for a target web service based on its formal WSDL service description. Using classes generated by this approach adds build time type checking and in-process like object behavior, i.e. using C++ data types as parameters and return values of each of the web service's methods.</para>
      </listitem>

      <listitem>
        <para>What can you use &kdsoap; for?</para>

        <para>&kdsoap; is used by a variety of programs for a variety of
        different purposes. For example, one application uses &kdsoap; to
        access data from a CRM system such as SugarCRM or Salesforce.
        For other examples, visit our web site at <ulink
        url="http://www.kdab.com/kdsoap"><filename>http://www.kdab.com/kdsoap/&kdsoap_cur_version;/</filename></ulink></para>
      </listitem>
    </itemizedlist>

    <sect1>
      <title id="prerequisites">What You Should Know</title>

      <para>You should be familiar with writing Qt applications, and have a
      working knowledge of C++. When you are in doubt about how a Qt class
      mentioned in this Programmer's Manual works, please check the Qt
      reference documentation or a good book about Qt. A more in-depth
      introduction to the API can be found in the file
      <filename>doc/KDSoap-1.0-API-Introduction</filename>. Also to browse
      &kdsoap; API Reference start with the file
      <filename>doc/refman/index.html</filename> or <ulink url="http://www.kdab.com/kdsoap"><filename>http://docs.kdab.com/kdsoap/</filename></ulink>.</para>
    </sect1>

    <sect1>
      <title id="structure">The Structure of This Manual</title>

      <para>Where do we start?</para>

      <para>This manual begins with an introduction to the &kdsoap1; API then
      goes through the basic steps and methods for the user to create her own
      SOAP client.</para>

      <para>Each subsequent chapter covers more advanced material like different variations of asynchronous calls or providing additional data to the transport protocol layer.
      <xref linkend="chtxt_kdwsdl2cpp" /> finally describes a less generic but easier and safer to use approach using generated code.</para>

      <para>We provide you with many more example programs than shown in this
      manual. We recommend that you try them out and run them. Have a
      look at the code and experiment with the various settings, both by
      adjusting them via the user interface, and by trying out your own code
      modifications.</para>
    </sect1>

    <sect1>
      <title>What's next</title>

      <para>In the next chapter we introduce the &kdsoap1; API.</para>
    </sect1>
  </chapter>

  <!-- ============ Kd Soap 1.0 Api Introduction ============= -->

  <chapter id="chapter_api">
    <title id="chtxt_api">&kdsoap1; API Introduction</title>

    <titleabbrev id="chnum_api">Chapter 2</titleabbrev>

    <para>&kdsoap; builds on technologies introduced with Qt 4, most importantly <classname>QNetworkAccessManager</classname>.
    This ensures that HTTP requests done by &kdsoap; will follow the operating system's proxy settings and be able to correctly process cookies.</para>

    <sect1>
      <title id="apioverview">Overview</title>

      <sect2>
        <title id="apisample" xreflabel="codesample">Code Sample</title>

        <programlisting>
const QString endPoint = QLatin1String("http://www.27seconds.com/Holidays/US/Dates/USHolidayDates.asmx");
const QString messageNamespace = QLatin1String("http://www.27seconds.com/Holidays/US/Dates/");

KDSoapClientInterface client(endPoint, messageNamespace);

KDSoapMessage message;
message.addArgument(QLatin1String("year"), 2010);

KDSoapMessage response = client.call(QLatin1String("GetValentinesDay"), message);
        </programlisting>

        <para>The code example shows the three basic steps for calling a web service method.</para>

        <itemizedlist>
          <listitem>
            <para>Setup of the proxy object used for interfacing with the web service.</para>
          </listitem>
          <listitem>
            <para>Construction of the method call's parameters.</para>
          </listitem>
          <listitem>
            <para>Performing the remote call.</para>
          </listitem>
        </itemizedlist>

        <para>The response, i.e. either the call's return value or an error structure, is delivered in the same abstract form the call parameters where constructed in. Therefore simple use cases like this sample only require use of two classes: <classname>KDSoapClientInterface</classname> and <classname>KDSoapMessage</classname></para>
      </sect2>

      <sect2>
        <title id="apiconcepts">Concepts</title>

        <para>For now, to get an overview about the &kdsoap1; API and its
        features, you need to understand the following basic concepts:</para>

        <itemizedlist>
          <listitem>
            <para>All interactions with web services happens through instances of <classname>KDSoapClientInterface</classname>. One such instance is needed for each web service an application wants to interact with, i.e. it is not possible to switch an instance to a different service at runtime.</para>
            <para><classname>KDSoapClientInterface</classname> provides functionality to make synchronous and asynchronous method calls. The first can be convenient in non-interactive applications or when used in threads, the latter is also suitable for use in a GUI application's main thread.</para>
          </listitem>

          <listitem>
            <para>Web service method calls require the name of the method and a single parameter object of type <classname>KDSoapMessage</classname>. Optional data such as SOAP request headers, e.g. for passing a session identifier alongside the request, can be passed with each method call or set permanently on the client interface instance.</para>
            <para>The single parameter object can contain an arbitrary number of named parameter values, each potentially again being a list. Simple types such as numbers or strings are representable by a single parameter value; complex types, e.g. a structure with multiple members, can be represented as a list of said members.</para>
            <programlisting>
KDSoapMessage message;

// add a simple type argument
message.addArgument(QLatin1String("text"), "some text");

// add a structured type argument
QRect rect(0, 0, 100, 200);
KDSoapValueList rectArgument;
rectArgument.addArgument(QLatin1String("x"), rect.x());
rectArgument.addArgument(QLatin1String("y"), rect.y());
rectArgument.addArgument(QLatin1String("width"), rect.width());
rectArgument.addArgument(QLatin1String("height"), rect.height());

message.addArgument(QLatin1String("rect"), rectArgument);
            </programlisting>
          </listitem>

          <listitem>
            <para>The call result is also of type <classname>KDSoapMessage</classname>, allowing structured data to be returned, similar to how a C++ method can return a class type.</para>
            <para>SOAP calls can result in an error being returned rather than a method return value, e.g. the web service might not be reachable due to network problems, the method might be unknown to the web service, etc. In such cases the returned <classname>KDSoapMessage</classname> is marked as a fault message, see <methodname>KDSoapMessage::isFault()</methodname>.</para>
          </listitem>
        </itemizedlist>
      </sect2>
    </sect1>
  </chapter>

  <chapter id="chapter_calls">
    <title id="chtxt_calls">Synchronous vs. Asynchronous Calls</title>

    <titleabbrev id="chnum_calls">Chapter 3</titleabbrev>

      <para>As shown in <xref linkend="apisample" />, calling a web service method is mapped by &kdsoap; to calling a method on a <classname>KDSoapClientInterface</classname> instance. This kind of abstraction makes day-to-day work with web services convenient, however, it is important to consider the involved processing steps when deciding where and how the application makes use of this simplification layer.</para>
      <para>The involved steps in the client to web service direction are:</para>

      <itemizedlist>
        <listitem>
          <para>Creation of an XML document for describing the method to call and its parameters.</para>
        </listitem>
        <listitem>
          <para>Sending of the XML document via a network connection using HTTP.</para>
        </listitem>
        <listitem>
          <para>Processing of the XML document on the web service's host.</para>
        </listitem>
      </itemizedlist>

      <para>The same applies for the reverse direction with the only difference being the semantics of the document content (method return value or error instead of method call).</para>
      <para>While the first and last step require some time for XML processing they are, depending on complexity of the involved parameter or return value data types, negligible compared to the middle one, due to it being subject to network latency and bandwidth limitations which in turn are often unpredictable.</para>

    <sect1>
      <title id="synchronouscalls">Synchronous Calls</title>

      <para>Calls performed by invoking the <classname>KDSoapClientInterface</classname>'s <methodname>call()</methodname> method are synchronous calls. Synchronous means that the calling thread will not return from the method before it has completed the full roundtrip processing. Due to its similarity with an in-process method call it is the easier to deploy variant supported by &kdsoap;. However, it should only be used when its blocking nature is of little concern, e.g. in a worker thread or in a non-interactive application like a command line tool.</para>
    </sect1>

    <sect1>
      <title id="asynchronouscalls">Asynchronous Calls</title>

      <para>Calls performed by invoking the <methodname>KDSoapClientInterface::asyncCall()</methodname> method are asynchronous calls. Asynchronous means that the calling thread will only process step one (XML generation) and create an HTTP transfer request. It will neither wait for the transfer's execution nor any response, but instead will return an instance of <classname>KDSoapPendingCall</classname>. This object then serves as a handle to determine at any later point whether the whole processing chain has been completed and what the resulting return value is.</para>

     <para>Performing the call from <xref linkend="apisample" /> in an asynchronous way:</para>
     <programlisting>
...
// mPendingCall is a member variable so it lives beyond
// the scope of the method creating it and so is mClient
mPendingCall = mClient-&gt;asynCall(QLatin1String("GetValentinesDay"), message);

...

if ( mPendingCall.isFinished() ) {
  KDSoapMessage response = mPendingCall.returnMessage();
}
     </programlisting>

     <para>Of course, checking for completion at some arbitrary time might not very be useful, instead the application will most likely want to be notified about the call's completion. This is supported by <classname>KDSoapPendingCallWatcher</classname>.</para>
     <programlisting>
...

KDSoapPendingCall pendingCall = mClient-&gt;asyncCall(QLatin1String("GetValentinesDay"), message);

// create a watcher object that will signal the call's completion
KDSoapPendingCallWatcher* watcher = new KDSoapPendingCallWatcher(pendingCall, this);
connect(watcher, SIGNAL(finished(KDSoapPendingCallWatcher*)),
        this, SLOT(pendingCallFinished(KDSoapPendingCallWatcher*)));
...

void MyClass::pendingCallFinished(KDSoapPendingCallWatcher* pendingCall)
{
  KDSoapMessage response = pendingCall->returnMessage();
}
     </programlisting>

     <para>Both variants support having more than one call pending, i.e. calling another web service method while a previous call is still being processed. However, there might be restrictions on the web service's side, e.g. not allowing more than one call per client at any given time to limit resource usage. In general it is also undetermined whether the results arrive in the same or a different order than the one the requests were sent in. A safer solution for multiple concurrent calls is to use multiple instances of KDSoapClientInterface, which results in multiple independent connections to the web service.</para>

     <para>Sometimes it might not be necessary at all to know whether a call succeeded or what its result was. In such cases use <methodname>KDSoapClientInterface::callNoReply()</methodname> instead.</para>
    </sect1>
  </chapter>

  <chapter id="chapter_headers">
    <title id="chtxt_headers">SOAP Headers</title>

    <titleabbrev id="chnum_headers">Chapter 4</titleabbrev>

    <para>SOAP specifies a mechanism to transmit data along side the actual SOAP document, so called SOAP headers. The term headers indicates that these values will be part of the HTTP headers section which makes them accessible for components involved in the transfer which do understand HTTP but might not have SOAP capabilities, e.g. the web server or a load balancer in front of it.</para>

    <para>&kdsoap; supports headers on a per method call basis as well as keeping them as local state across calls.</para>

    <sect1>
      <title id="perinterfaceheaders">SOAP Headers per Client Interface</title>

      <para>One of the most common use case for SOAP headers is providing session information for the recipient of the SOAP transmission. This is mainly necessary because HTTP is a stateless interfacing scheme, where each call arrives through a new network connection. In order to associate such independent connections to the same client, the first connection establishes some sort of session tracking, usually in the form of a session identifier string. This identifier then has to be provided with each call.</para>

      <para>While a header containing such an identifier could be provided at each method call, it will usually be more convenient to let &kdsoap; take care of that by setting the header as a kind of local state on the <classname>KDSoapClientInterface</classname> instance:</para>

     <programlisting>
KDSoapMessage message;
message.addArgument(QLatin1String("user"), userName);
message.addArgument(QLatin1String("password"), password);

KDSoapMessage response = client.call(QLatin1String("Login"), message);
const QString sessionId = response.arguments()[0].value().toString();

KDSoapMessage header;
header.addArgument(QLatin1String("SessionId"), sessionId);

client.setHeader(QLatin1String("SessionHeader"), header);

...

response = client.call(QLatin1String("GetUserDetails", KDSoapMessage());
     </programlisting>

     <para>The example above assumes a fictitious web service which requires a login call to establish a user's authentification and then requires the returned session token to be used for any subsequent call. Setting the identifier as a header allows &kdsoap; to take care of sending it alongside any call invoked through the same <classname>KDSoapClientInterface</classname> instance.</para>

     <para>Please note that the actual name of the header argument, in the case of this example <literal>"SessionId"</literal>, is part of the web service's interface description, while the name passed to <methodname>KDSoapClientInterface::setHeader()</methodname> is purely used for identifying the header between &kdsoap; and the application and can thus be chosen by the user herself.</para>
    </sect1>

    <sect1>
      <title id="percallheaders">SOAP Headers for Single Calls</title>

      <para>Sometimes it might not be possible to use a header across calls, e.g. the value of the header changing with each call or be specific to the method being called. In cases like this it is necessary to provide the headers when invoking the <methodname>KDSoapClientInterface::call()</methodname> (or one of its asynchronous variants):</para>

     <programlisting>
KDSoapMessage header;
header.addArgument(QLatin1String("SessionId"), sessionId);

KDSoapHeaders headers;
headers &lt;&lt; header;

response = client.call(QLatin1String("GetUserDetails", KDSoapMessage(), QString(), headers);
     </programlisting>

     <sect2>
       <title id="soapaction">SOAP Action</title>

       <para>As already hinted in the example above, there is another per-call parameter: SOAP Actions. It is a mandatory SOAP header but allowed to be empty. Its purpose as suggested by the SOAP specification is to express the intent of the call. In most cases this can be left empty and let &kdsoap; generate a valid value based on the method name.</para>

       <para>As an example of where it is necessary to actually set this, see Google's search API:</para>

       <programlisting>
KDSoapMessage message;

...

const soapAction = QLatin1String("urn:GoogleSearchAction");
KDSoapMessage response.call(QLatin1String("doGoogleSearch"), message, soapAction);
       </programlisting>
     </sect2>
    </sect1>
  </chapter>

  <chapter id="chapter_kdwsdl2cpp">
    <title id="chtxt_kdwsdl2cpp">Using WSDL to Generate Client API</title>

    <titleabbrev id="chnum_kdwsdl2cpp">Chapter 4</titleabbrev>

    <sect1>
      <title id="wsdlintroduction">Introduction</title>

      <para>Most SOAP based web services are formally described in an XML based markup language called web service description language (WSDL). Such WSDL documents describe web service methods, their parameters and return values, as well as possible errors in a formalized way that makes them viable as input for code generation tools.</para>

      <para>Compared to the generic approach described in the earlier chapters of this manual, using a generated client API introduces several additional advantages:</para>

      <itemizedlist>
        <listitem>
          <para>Named methods: instead of referring to web service methods by names as string parameters to a generic <methodname>call()</methodname> method, a client interface generated from a WSDL document will have C++ methods for each of the web service's methods.</para>
        </listitem>

        <listitem>
          <para>Type specific classes: instead of building a single message object containing the method's parameters as lists of named values, methods of a generated client interface take C++ types for each of their parameters. If such a parameter is a type described in the WSDL document, a matching class with suitably named methods and again specific types will have been generated as well.</para>
        </listitem>

        <listitem>
          <para>Build time checks: as a result of neither methods nor parameter or return types being generic anymore, typos in method or parameter names, missing parameters and some forms of invalid parameter contents can now be caught by the C++ compiler instead of resulting in a SOAP error at runtime during method invocation.</para>
        </listitem>
      </itemizedlist>

      <para>&kdsoap; has full support for this powerful approach through its &kdwsdl2cpp; code generation tool. The following sections document how to use it and the client API it generates.</para>
    </sect1>

    <sect1>
      <title id="usingkdwsld2cpp">Using &kdwsdl2cpp;</title>

      <para>Before using &kdwsdl2cpp; it is necessary to obtain the WSDL document describing the target web service and have it available as a local file. It usually available as a download on a web site associated with the web service or similar online distribution methods.</para>

      <para>Code generation using &kdwsdl2cpp; requires two steps: one to generate the header file and one to generate the source file. For example, when processing the <filename>holidays.wsdl</filename> file (which can be found in <filename>examples/holidays_wsdl</filename>) the following two commands need to be executed:</para>

      <para><userinput>kdwsdl2cpp -o wsdl_holidays.h holidays.wsdl</userinput></para>

      <para>This creates a header file <filename>wsdl_holidays.h</filename> (choice of file name is up to the user), which will then contain the declarations of all data classes described in th WSDL file as well as the class representing the web service's interface.</para>

      <para><userinput>kdwsdl2cpp -o wsdl_holidays.cpp -impl wsdl_holidays.h holidays.wsdl</userinput></para>

      <para>This creates a source file <filename>wsdl_holidays.cpp</filename> (choice of file name is again up to the user) using the header file <filename>wsdl_holidays.h</filename> as the include for class declarations.</para>
    </sect1>

    <sect1>
      <title id="generatedcode">Using the Generated Code</title>

      <para>The generated code for the example call used through out this manual looks like this:</para>
      <programlisting>
class USHolidayDates : public QObject
{
    Q_OBJECT

public:
    USHolidayDates( QObject* parent = 0 );
    ~USHolidayDates();

    TNS__GetValentinesDayResponse getValentinesDay( const TNS__GetValentinesDay&amp; parameters );

    void asyncGetValentinesDay( const TNS__GetValentinesDay&amp; parameters );

    void getValentinesDayDone( const TNS__GetValentinesDayResponse&amp; parameters );

    void getValentinesDayError( const KDSoapMessage&amp; fault );
};
      </programlisting>
      <para>This is an excerpt of the generated web service interface class. It is a subclass of <classname>QObject</classname> so it can make use of signals for delivering asynchronous results. Both synchronous as well as asynchronous calls take an instance of the generate class <classname>TNS__GetValentinesDay</classname> as their only parameter. The synchronous variant returns an instance of class <classname>TNS__GetValentinesDayResponse</classname> once it has completed the call, while the asynchronous <methodname>asyncGetValentinesDay()</methodname> returns without value. Its results are delivered through one of the two signals: <methodname>getValentinesDayDone()</methodname> which carries an instance of the same response class returned by the synchronous <methodname>getValentinesDay()</methodname>, or <methodname>getValentinesDayError()</methodname> which carries a fault message (see <xref linkend="apiconcepts" />).</para>

      <programlisting>
class TNS__GetValentinesDay
{
public:
    void setYear( int year );
    int year() const;
};
      </programlisting>

      <para>This is an excerpt of the generated request parameter class, using the native integer type for the year parameter.</para>

      <programlisting>
class TNS__GetValentinesDayResponse
{
public:
    void setGetValentinesDayResult( const QDateTime&amp; getValentinesDayResult );
    QDateTime getValentinesDayResult() const;
};
      </programlisting>

      <para>This is an excerpt of the generated return value class, using Qt's <classname>QDateTime</classname> to represent the resulting date.</para>

      <para>Deploying these classes to perform the example call:</para>

      <programlisting>
USHolidayDates client;

TNS__GetValentinesDay request;
resquest.setYear( 2010 );

TNS__GetValentinesDayResponse response = client.getValentinesDay( request );
const QDateTime valentinesDay = response.getValentinesDayResult();
      </programlisting>
    </sect1>

    <sect1>
      <title id="kdwsdl2cppqmake">Using &kdwsdl2cpp; with QMake</title>

      <para>While running &kdwsdl2cpp; manually and adding the resulting source and header file to a project's QMake <filename>.pro</filename> file works as expected, having QMake take care of the code generation makes it easier to adopt changes in the WSDL file.</para>

      <para>&kdsoap; supports this by making WSDL file processing similar to how QMake treats Qt Designer's <filename>.ui</filename> files. The necessary steps are:</para>

      <itemizedlist>
        <listitem>
          <para>Include the <filename>kdsoap.pri</filename> QMake include file in the project's <filename>.pro</filename> file. It is part of the &kdsoap; package and should be copied to the user's project directory.</para>
        </listitem>

        <listitem>
          <para>Add the WSDL files to the <literal>KDWSDL</literal> variable. For the example above it would look like this:</para>
          <programlisting>
KDWSDL = holidays.wsdl
          </programlisting>
          <para>Generated files will be prefixed with <literal>wsdl_</literal> and have the proper extension depending on file type. I.e. the above line will result in <filename>wsdl_holidays.h</filename> and <filename>wsdl_holidays.cpp</filename>.</para>
        </listitem>

        <listitem>
          <para>Set the environment variable <literal>KDSOAPDIR</literal> to the base path of your &kdsoap; build or install directory or provide it as a value to the <filename>qmake</filename> run.</para>
        </listitem>
      </itemizedlist>
    </sect1>
  </chapter>

  <appendix id="appendix_qanda">
    <title id="txt_appendix_qanda">Q&amp;A section</title>

    <titleabbrev>Appendix A</titleabbrev>

    <qandaset defaultlabel="number">
      <qandadiv>
        <title>Building and installing &kdsoap;</title>

        <qandaentry id="qa_install1">
          <question>
            <para>How can I build and install &kdsoap; from source?</para>
          </question>

          <answer>
            <para>Procedure to follow for building and installing &kdsoap; is
            described in file <filename>Install.src</filename>, please refer
            to that file for details.</para>
          </answer>
        </qandaentry>
      </qandadiv>

      <qandadiv>
        <title>Contacting &kdsoap; Support</title>

        <qandaentry id="qa_contact_support">
          <question>
            <para>How can I get help (or report issues, resp.) on
            &kdsoap;?</para>
          </question>

          <answer>
            <para>To report issues/problems, or ask for help on &kdsoap;
            please send your mail with a description of your
            problem/question/wishes to the support address given to you with
            your license. Please include a description of your setup: CPU
            type, operating system with release number, compiler (version)
            used, any changes you made on libraries that are linked to ...
            Just include every detail that might help us set up a comparable
            test environment in our labs.</para>

            <para>In most cases it will make sense to include a small sample
            program showing the problem you are describing: We will then
            reproduce the issue on our machines and either fix your sample
            code or adjust our own code (in case your reported issue might
            turn out to result from sub-optimal implementation in
            &kdsoap;).</para>

            <note>
              <para>Providing us with a compilable sample program file will
              help us find a good solution for the problem reported, as we
              will be using the same code that you have been trying to use
              yourself.</para>
            </note>

            <para>Often the easiest way to create such a sample program could
            be to look at one of our example programs, e.g.
            <filename>examples/holidays_wsdl/holidays.cpp</filename> and do something similar just with your WSDL file.</para>
            <para>If the webservice is not available to us, e.g. is software not available as at least a trial version and you (or your customer) not allowed to create a test account for us on your installation, we'll probably require logs of the SOAP communication as well.</para>
            <para>&kdsoap; has built-in functionality to print the SOAP communication to the application's standard output. To enables this either set the environment variable <literal>KDSOAP_DEBUG</literal> to <literal>1</literal> or put the following code into the test application:</para>
            <programlisting>
qputenv( "KDSOAP_DEBUG", "1" );
            </programlisting>
          </answer>
        </qandaentry>
      </qandadiv>
    </qandaset>
  </appendix>
</book>
